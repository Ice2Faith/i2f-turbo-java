<!--
为了编写这份xml的时候，减少一些记忆，借助编辑器对dtd的补全联想能力，因此提供一份参考的dtd约束
这份dtd约束，只是为了方便编写这份脚本，实际运行时会被删除这个约束，不影响实际运行结果
 -->
<!DOCTYPE procedure SYSTEM "procedure.dtd">
<!--
定义一个顺序的处理流程，能够进行逻辑控制与SQL执行，
实现使用脚本定义的方式，达到与存储过程相似的能力，核心使用一个Map构成的执行栈来维护执行的变量，
预期是既有编程语言的控制灵活度，也有数据库语句直接编写的识别度，
避免在java等编程语言中进行SQL语句的拼接操作

实现方案
采用xml格式编写控制脚本，语言控制与SQL语句都在xml中书写
script-开头的用于提供复用性片段
lang-开头的用于提供流程控制等能力，实现上考虑使用ongl/spel+velocity实现
sql-开头的用于提供JDBC操作能力，实现上考虑使用mybatis的xml格式进行处理

相关知识介绍：
xml XML解析技术
    实现：org.w3c.dom.Document
    用途：解析xml文件格式为XmlNode树节点
ognl 对象图导航语言
    实现：ognl.Ognl
    用途：用于eval/visit/test等用途，Mybatis中就是使用ognl来实现test和取值的
        因此，这部分，用法和Mybatis中基本一致，不排除ognl版本导致的一些差异/初始化ognl上下文导致的操作
    取值上：不需要进行任何包含
        但是在sql场景中，使用${}/#{}取值，用法上和Mybatis基本一致
velocity 文本模板引擎
    实现：org.apache.velocity.app.VelocityEngine
    用途：用于render用户，提供对字符串的模版渲染能力，可以用于字符串动态拼接等场景
    取值上：${}包含，表达式上：#()包含

属性修饰符：用在输入时，表示值怎么取，用在输出时，表示输出的目标类型，用在声明时，表示期待的输入类型
多个修饰符顺序执行，用.小数点隔开
.int 整型
.double 浮点型
.float 短浮点型
.string 字符串
.long 长整型
.short 短整型
.char 字符型
.byte 字节型
.boolean 布尔型
.render 渲染占位，以模版引擎方式渲染字符串
.visit 访问属性，使用访问属性方式访问params中的属性
.eval 计算值，使用默认方式计算表达式的值
.test 使用测试方法，使用默认方式测试表达式的值
.null 空值
.date 日期时间型，需要标签指定pattern属性，没有的话会尝试可行的解析
.trim 用于在字符型变量时进行先trim后使用，输出时，先trim后输出
.align 用于在字符值时，对左边多余的空白符号予以去除，但是需要以|引导字符串行
.body-text 用于表示值从标签内部获取
.body-xml 用于表示值从标签内部获取

.eval-java 以java表达式解析
.eval-js 以js表达式解析
.class 转换为Class<?> 对象
.not boolean值取反

注意，未标明的修饰符
不会被处理，会被跳过处理
因此，请注意修饰符的拼写
同时，这也允许你使用一些自己喜欢的标识符来说明一些事情
比如：
.in 表示入参
.out 表述出参
.inout 表示入出参

属性修饰符，使用举例说明
value.string.long.int=“1”
表示value属性的值，从表达式1开始
先转为string字符串
再转为long数值型
再转为int整形
最终就是整形的1

还有，再一些场景中
某些属性具有默认的属性修饰符，也就是默认行为
可以通过添加自己的属性修饰符，大概改变默认行为的目的
比如，tag默认是string的修饰符，也就是字节取属性的字符串，但是可以通过 tag.visit改变行为为从params参数取一个字符串
也可以用于类型转换的场景中使用
再比如，再lang-set场景中，value默认是visit修饰符，
可以使用value.string直接输入字符串，
或者使用eval/eval-java等修饰符改变行为为获取eval的结果

eval是使用ognl进行实现
ognl将会以上下文的Map对象为根对象
同时会添加名为$root的变量，也是这个上下文Map
参见：DefaultJdbcProcedureExecutor.innerEval

eval-java是使用jdk的内存编译技术实现的
原理是封装为一个临时的类，执行固定方法实现
函数原型如下：
public Object exec(ExecuteContext context, JdbcProcedureExecutor executor,Map<String,Object> params) throws Throwable {
}
或者参见：JdbcProcedureJavaCaller接口定义
因此，你要做的就是补全函数体内部的内容
如果是多行或者单行时，会自动检测最后的return关键字和分号进行补全
例如：new Date()
即可，不用 return new Date();
但是如果比较复杂，那最好还是自己完善语法

eval-js使用java中的js引擎进行处理
以局部作用域的方式运行，局部变量中和java一样，传递了三个参数context,executor,params
你可以添加自己的逻辑
js引擎执行完毕之后，会返回之后一次执行的结果
 -->
<procedure id="">
    <!--
    使用系统输出行，以tag开头，其余变量附加在其他属性上即可
    tag默认以字符串方式解析，等价于 tag.string
     -->
    <lang-println tag="" aaa=""/>

    <!--
    使用value指定的模版进行渲染输出,同样支持tag属性标签
    tag默认以字符串方式解析，等价于 tag.string
     -->
    <lang-printf tag="" value.body-xml.trim=""/>

    <!-- 语句段，可使用script-include进行引用，id唯一即可，root表示语句段使用了哪些变量，可以作为变量声明 -->
    <script-segment id="" root="">
        <![CDATA[
            112
        ]]>
    </script-segment>
    <!-- 引用语句段，可使用script-segment定义的语句段，refid表示引用的语句段，其他属性表示传递给语句段的根变量 -->
    <script-include refid="" root="" aaa=""/>

    <!--
    从value指定的值赋值到result指定的值中，
    如果为数值型，可以使用radix指定进制
    如果为日期型，可以使用pattern指定格式化的串
    这里value为输入，又添加了:int修饰符，则表示这个值是一个int型立即数，不需要从context里面取
    value默认以visit访问，等价于 value.visit
    radix默认以int访问，等价于 radix.int
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-set value.int="" radix="" pattern="" result=""/>

    <!--
    格式化日期
    value默认以visit访问，等价于 value.visit
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-format-date value="" pattern="" result=""/>
    <!--
    格式化字符串
    value默认以visit访问，等价于 value.visit
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-format value="" pattern="" result=""/>

    <!--
    字符串拼接
    separator默认以string访问，等价于 separator.string
    其他argx以visit访问，等价于 argx.visit
     -->
    <lang-string-join separator="" result="" arg0="" arg1=""/>

    <!--
    创建一个新的参数，用于为内部调用其他过程提供干净的上下文参数，避免参数污染
    同时，由于被调用方的上下文参数在调用方持有，调用方也可以获取到被调用方执行完的结果
    传入参数默认以visit访问，等价于 aaa.visit
    -->
    <lang-new-params result="" aaa="" bbb=""/>

    <!--
    调用其他存储过程，id表示目标的id,
    可以指定一个params参数作为根上下文参数，这样可以避免上下文污染，如果不指定，则直接使用新的上下文，新的上下文可用过result进行获取到
    直接使用目标变量age名来传递值
    params默认以visit访问，等价于 params.visit
    result为保存调用的参数，可用于从中获取调用的结果，如果同时指定的params，则result可以不用指定，因为result里面的值，实际上就是params里面的值
    其他传入参数默认以visit访问，等价于 age.visit
     -->
    <procedure-call refid="" params="" age="" result=""/>

    <!--
    调用java指定的回调方法
    target需要为JdbcProcedureJavaCaller的实现类
    优先从上下文Map的beans中进行获取
    如果获取不到再从params中获取
    获取得到，并且是实现类则进行调用
    否则不进行调用
    -->
    <java-call target="" result=""/>

    <!-- 返回，结束此过程 -->
    <lang-return/>

    <!--
    抛出异常，value指定为message内容，type指定为异常类型，cause可选为造成异常的异常对象
    value默认以string访问，等价于 value.string
    type以string访问，不支持修饰符
    cause以visit访问，不支持修饰符
     -->
    <lang-throw value="" type="" cause=""/>

    <!--
    用于指定一小段脚本，来设置一个变量值到result指定的变量名中
    value默认以string访问，等价于 value.string
     -->
    <lang-eval value="" result="">
        11
    </lang-eval>
    <!-- 用于指定一段字符串到result指定的变量名中 -->
    <lang-string result="">

    </lang-string>
    <!-- 用于使用模版引擎进行渲染一段字符串到result指定的变量名中 -->
    <lang-render result="">

    </lang-render>
    <!--
    lang-开头的表示语言的基本语句，这个就是对应if语句，test表示判定条件语句
    test默认以test访问，等价于 test.test
     -->
    <lang-if test="">

    </lang-if>
    <!-- 对应的就是if-else-if这种语句或者Switch这种分支语句 -->
    <lang-choose>
        <!--
        表示一个分支
        test默认以test访问，等价于 test.test
         -->
        <lang-when test="">

        </lang-when>
        <!-- 其他分支，当所有when分支都不满足时，执行此分支，对应else分支 -->
        <lang-otherwise>

        </lang-otherwise>
    </lang-choose>
    <!--
    对应一个foreach循环，对一个集合进行迭代，collection表示被迭代的集合，item表示迭代变量的名称
    item默认值为item，可缺省
    first默认值为first，可缺省
    index默认值为index，可缺省
    collection以visit访问，不支持修饰符
    item以string访问，不支持修饰符
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-foreach collection="" item="" first="" index="">

    </lang-foreach>
    <!--
    对应一个计数型循环，表示从begin数开始每次增加incr的步长直到end结束，item表示迭代变量的名称
    begin默认值为0，可缺省
    incr默认值为1，可缺省
    item默认值为item，可缺省
    first默认值为first，可缺省
    index默认值为index，可缺省
    begin默认以int访问，等价于 begin.int
    end默认以int访问，等价于 end.int
    incr默认以int访问，等价于 incr.int
    item以string访问，不支持修饰符
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-fori begin="" end="" incr="" item="" first="" index="">

    </lang-fori>
    <!--
    对应一个while语句，test表示循环条件的判断语句
    first默认值为first，可缺省
    index默认值为index，可缺省
    test默认以test访问，等价于 test.test
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-while test="" first="" index="">
        <!-- 对应continue-->
        <lang-continue/>
        <!-- 对应break -->
        <lang-break/>
    </lang-while>
    <!--
    调用函数，在target指定的对象上调用method方法，并传入argx参数
    当指定target时，method不用指定类名
    当method是静态函数式，target没有影响
    method是全限定的方法名（即类名.方法名，例如Math.random,Date.new）,
    new方法名，指调用构造函数
    target表示在哪个对象上调用（有target时，不需要指定全限定方法名，只需要方法名即可）,
    argx表示传入的参数，后面的数字表示参数的次序，
    result用于记录调用的结果保存到哪个变量中
    method以string访问，不支持修饰符
    target默认以visit访问，等价于 target.visit
     -->
    <lang-invoke method="" target="" arg0="" arg1="" result=""/>
    <!-- 对应一个异常处理块try-catch-finally -->
    <lang-try>
        <!-- 表示异常处理的内容，对应try的内容块 -->
        <lang-body>

        </lang-body>
        <!--
        表示一个异常catch块，type指定要捕获的异常类型，var表示异常的变量名
        type以string访问，不支持修饰符
        e以string访问，不支持修饰符
         -->
        <lang-catch type="" e="">

        </lang-catch>
        <!-- 对应finally语句块 -->
        <lang-finally>

        </lang-finally>
    </lang-try>

    <!--
    对应synchronized关键字,允许指定target，不指定则对当前节点的上下文context同步
    target默认以visit访问，等价于 target.visit
     -->
    <lang-synchronized target="">

    </lang-synchronized>
    <!--
    表示一个查询语句，预期为一行数据，执行结果放到result指定的变量名中；
    对于sql-开头的标签，都允许带有datasource属性来制定使用哪个数据源，也都允许带有script属性指定要执行的SQL来源于哪个变量，
    对于sql-query-开头的标签，都允许带有result-type属性来指定结果集转换为什么类型
    datasource默认以string访问，等价于 datasource.string
    script默认以visit访问，等价于 script.visit
    result-type默认以class访问，等价于 result-type.class
     -->
    <sql-query-row datasource="" script="" result="" result-type="">

    </sql-query-row>
    <!-- 表示一个查询语句，预期为多行数据，执行结果放到result指定的变量名中 -->
    <sql-query-list result="">
        <trim prefix="select" prefixOverrides="," suffixOverrides=",">
            id,
            username,
            <if test="false">
                password,
            </if>
            nickname,
        </trim>
        from sys_user
        <where>
            <if test="true">
                <choose>
                    <when test="true">

                    </when>
                    <when test="true">

                    </when>
                    <otherwise>

                    </otherwise>
                </choose>
            </if>
            <foreach collection="list" item="item" open="(" separator="," close=")">

            </foreach>
            <include refid="permsCondition"/>
        </where>
    </sql-query-list>
    <!-- 表示一个查询语句，预期为单个值，仅一行一列的值，执行结果放到result指定的变量中 -->
    <sql-query-object result="">

    </sql-query-object>
    <!-- 表示一个更新语句，预期为JDBC执行update的返回值，执行结果放到result指定的变量中 -->
    <sql-update result="">
        <!--
         用于在sql-系列的标签中，用于解决数据库的方言问题
         通过databases指定支持的数据库类型列表，多个用逗号分隔，不区分大小写
         允许使用script属性指定脚本
         这个标签是可选的
          script默认以visit访问，等价于 script.visit
          databases以string访问，不支持修饰符
         -->
        <sql-dialect script="" databases="mysql,gbase,mariadb">
            update sys_user
            <set>
                <if test="true">
                    username=#{username}
                </if>
            </set>
            <where>
                id=#{id}
            </where>
        </sql-dialect>
        <sql-dialect databases="oracle,dm">
            delete from sys_user
            where
            <if test="true">
                id=#{id}
            </if>
        </sql-dialect>
        <sql-dialect databases="postgre">
            insert into sys_user
            <trim prefix="(" suffix=")" prefixOverrides="," suffixOverrides=",">
                <if test="true">
                    username,
                </if>
            </trim>
            values
            <trim prefix="(" suffix=")" prefixOverrides="," suffixOverrides=",">
                <if test="true">
                    #{username},
                </if>
            </trim>
        </sql-dialect>
        <sql-dialect databases="sqlserver">

        </sql-dialect>
    </sql-update>

    <!--
    表示JDBC的事务控制，begin表示开始事务。commit表示提交事务，rollback表示回滚事务,none表示不开启事务
    isolation以string访问，支持Connection.TRANSACTION_xxx的数字值，或者xxx的字符值，不区分大小写
     -->
    <sql-trans-begin isolation=""/>
    <sql-trans-commit/>
    <sql-trans-rollback/>
    <sql-trans-none/>

    <!--
    异步执行，await表示是否需要等待执行结束，delay表示延迟多长时间再开始执行
    await默认以boolean访问，等价于 await.boolean
    delay默认以long访问，等价于 delay.long
    time-unit以string访问，不支持修饰符，为TimeUnit的枚举字符串值，不区分大小写
     -->
    <lang-async await.boolean="" delay="" time-unit="">

    </lang-async>
    <!--
    java 中的count-down-latch
    count默认以eval访问，等价于 count.eval ，因为使用latch的场景大多数和集合等有关，所以选用默认eval类方便获取集合的大小
     -->
    <lang-latch count="" result=""/>
    <!--
    多个任务并行
    await默认以boolean访问，等价于 await.boolean
     -->
    <lang-async-all await="">
        <!-- 每个任务仅有delay延时可用 -->
        <lang-async delay="" time-unit="">
            <!--
            对name对应的latch对象进行count-down操作
            name默认以visit访问，等价于 name.visit 目的是取到对应的latch对象
             -->
            <lang-latch-down name=""/>
        </lang-async>
    </lang-async-all>
    <!--
    等待名为name的latch对象
    name默认以visit访问，等价于 name.visit 目的是取到对应的latch对象
    timeout默认以long访问，等价于 timeout.long
    time-unit以string访问，不支持修饰符，为TimeUnit的枚举字符串值，不区分大小写
     -->
    <lang-latch-await name="" timeout="" time-unit=""/>


    <!--
    通过遍历结果集的方式，提供类似游标的操作能力，通过sql-query-list进行查询遍历，
    每次查询分页大小为batch-size，将item的值提供给lang-body进行执行
    如果accept-batch值为true，则传递给lang-body的item参数为一个batch-size大小的list
    否则，只是一行数据传给item
    batch-szie默认值为2000，可缺省
    item默认值为item，可缺省
    accept-batch默认值为false，可缺省
    batch-size默认以int访问，等价于 batch-size.int
    item以string访问，不支持修饰符
    accept-batch默认以boolean访问，等价于 accept-batch.boolean
     -->
    <sql-cursor batch-size="300" item="" accept-batch="false">
        <sql-query-list datasource="" script="" result-type="">

        </sql-query-list>
        <lang-body>
        </lang-body>
    </sql-cursor>

    <!-- 动态编译为java类进行执行 -->
    <lang-eval-java result="">
        <!-- import 语句部分 -->
        <lang-java-import>

        </lang-java-import>
        <!-- member语句部分，也就是成员变量和成员函数 -->
        <lang-java-member>

        </lang-java-member>
        <!-- body部分，需要带有return语句 -->
        <lang-java-body>

        </lang-java-body>
    </lang-eval-java>

    <!-- 动态执行javascript脚本 -->
    <lang-eval-javascript result="">

    </lang-eval-javascript>

    <!--
     创建一个数据库连接范围，对datasources中指定的这些数据源
     创建新的连接进行使用，使用完毕之后自动关闭新创建的这些连接
     同时，执行完毕之后，恢复域外的连接到上下文中
     多个数据源用逗号分隔，特别的，all表示全部数据源
     datasources使用string访问，不支持修饰符
     -->
    <sql-scope datasources="">

    </sql-scope>

    <!-- 对当前线程进行休眠 -->
    <lang-sleep timeout="" time-unit=""/>

    <!--
    进行数据库表ETL对拷，注意，此过程全程使用的是新链接
    每次从sql-query-list中读取read-batch-size个元素
    写入到load指定的数据源datasource的table表中
    允许在开头是进行before-truncate清空表操作
    在进行commit-size条数据的写入之后，提交一次事务
     -->
    <sql-etl read-batch-size=""
             write-batch-size=""
             before-truncate=""
             commit-size="">
        <sql-query-list>

        </sql-query-list>
        <!--
        进行列的转换，只有在target写明的列才会进行传输
        source表示原始的列名
        target表示目标列名，将用于load中构造插入语句的目标列名
        source默认使用string访问，等价于 source.string ,可使用其他修饰符实现原始数据的转换或覆盖
        target使用string访问，等价于 target.string, 不支持修饰符
        -->
        <etl-transform source="" target="" />
        <!--
        进行数据的写入，将数据写入到datasource指定的数据源中
        目标表用table表示
        -->
        <etl-load datasource="" table=""/>

        <!--
        两个声明周期钩子，分别对应ETL前和执行后的操作
        例如执行前清空表，或者删除目标表的部分数据
        或者ETL到的是临时表，ETL结束后再批量插入到目标表等场景
         -->
        <etl-before>

        </etl-before>
        <etl-after>

        </etl-after>
    </sql-etl>
</procedure>