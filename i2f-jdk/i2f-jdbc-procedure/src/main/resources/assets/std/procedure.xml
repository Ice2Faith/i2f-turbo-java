<!--
为了编写这份xml的时候，减少一些记忆，借助编辑器对dtd的补全联想能力，因此提供一份参考的dtd约束
这份dtd约束，只是为了方便编写这份脚本，实际运行时会被删除这个约束，不影响实际运行结果
 -->
<!DOCTYPE procedure SYSTEM "procedure.dtd">
<!--
定义一个顺序的处理流程，能够进行逻辑控制与SQL执行，
实现使用脚本定义的方式，达到与存储过程相似的能力，核心使用一个Map构成的执行栈来维护执行的变量，
预期是既有编程语言的控制灵活度，也有数据库语句直接编写的识别度，
避免在java等编程语言中进行SQL语句的拼接操作

======================================================

实现方案
采用xml格式编写控制脚本，语言控制与SQL语句都在xml中书写
script-开头的用于提供复用性片段
lang-开头的用于提供流程控制等能力，实现上考虑使用ongl/spel+velocity实现
sql-开头的用于提供JDBC操作能力，实现上考虑使用mybatis的xml格式进行处理

======================================================

相关知识介绍：
    xml XML解析技术
        实现：org.w3c.dom.Document
        用途：解析xml文件格式为XmlNode树节点
    ognl 对象图导航语言
        实现：ognl.Ognl
        用途：用于eval/visit/test等用途，Mybatis中就是使用ognl来实现test和取值的
            因此，这部分，用法和Mybatis中基本一致，不排除ognl版本导致的一些差异/初始化ognl上下文导致的操作
        取值上：不需要进行任何包含
            但是在sql场景中，使用${}/#{}取值，用法上和Mybatis基本一致
        语法官网：https://commons.apache.org/dormant/commons-ognl/language-guide.html
    velocity 文本模板引擎
        实现：org.apache.velocity.app.VelocityEngine
        用途：用于render用户，提供对字符串的模版渲染能力，可以用于字符串动态拼接等场景
        取值上：${}包含，表达式上：#()包含
        使用官网：https://velocity.apache.org/engine/devel/user-guide.html
额外技术：
    groovy 一种JVM平台的脚本语言，可理解为简化版的Java
        实现：groovy.lang.GroovyShell
        用途：用于支持习惯使用Groovy作为脚本语言的用户实现脚本嵌入
        使用官网：https://www.groovy-lang.org/syntax.html
    TinyScript 是一个为了适配此方案而诞生的轻量级脚本引擎
        实现：TinyScript.script
        用户：用于适配这种场景的一种偏向函数式过程语言
        原理；是基于antlr4技术实现的脚本语言

======================================================

属性修饰符：用在输入时，表示值怎么取，用在输出时，表示输出的目标类型，用在声明时，表示期待的输入类型
多个修饰符顺序执行，用.小数点隔开
.int 整型
.double 浮点型
.float 短浮点型
.string 字符串
.long 长整型
.short 短整型
.char 字符型
.byte 字节型
.boolean 布尔型
.render 渲染占位，以模版引擎方式渲染字符串
.visit 访问属性，使用访问属性方式访问params中的属性
.eval 计算值，使用默认方式计算表达式的值
.test 使用测试方法，使用默认方式测试表达式的值
.null 空值
.date 日期时间型，需要标签指定pattern属性，没有的话会尝试可行的解析
.trim 用于在字符型变量时进行先trim后使用，输出时，先trim后输出
.align 用于在字符值时，对左边多余的空白符号予以去除，但是需要以|引导字符串行
.body-text 用于表示值从标签内部获取
.body-xml 用于表示值从标签内部获取
.spacing-left 左边填充空格
.spacing-right 右边填充空格
.spacing 两边都填充空格

.eval-java 以java表达式解析
.eval-js 以js表达式解析
.eval-tinyscript 以tinyscript表达式解析，别名：.eval-ts
.eval-groovy 以groovy脚本运行
.class 转换为Class<?> 对象
.not boolean值取反

.dialect 方言属性，主要用于test属性上，用于表示指定的datasource支持哪些数据库类型
    用法：<lang-if test.dialect="mysql,oracle" datasource="primary">
    解释：需要使用.dialect修饰符，使用此修饰符时，需要添加datasource属性指定判断的数据源，如果datasource属性没指定，则表示对主数据源进行判断
    "mysql,oracle"就表示兼容的数据库类型
    这个示例中，表示需要判断datasource为primary的数据库类型在mysql,oracle中任意一个满足即可

is-null 判断是否为null
is-not-null 判断是否不为null
is-empty 判断是否为空，适用于string类型
is-not-empty 判断是否不为空，适用于string类型

date-now 当前时间，也就是值 new Date()
uuid 随机的UUID，也就是值 UUID.randomUUID().toString()
current-time-millis 当前的毫秒值，也就是值 System.currentTimeMillis()
snow-uid 雪花ID，也就是值 SnowflakeLongUid.getId()

======================================================
注意，未标明的修饰符
不会被处理，会被跳过处理
因此，请注意修饰符的拼写
同时，这也允许你使用一些自己喜欢的标识符来说明一些事情
比如：
.in 表示入参
.out 表述出参
.inout 表示入出参

属性修饰符，使用举例说明
value.string.long.int=“1”
表示value属性的值，从表达式1开始
先转为string字符串
再转为long数值型
再转为int整形
最终就是整形的1

还有，再一些场景中
某些属性具有默认的属性修饰符，也就是默认行为
可以通过添加自己的属性修饰符，大概改变默认行为的目的
比如，tag默认是string的修饰符，也就是字节取属性的字符串，但是可以通过 tag.visit改变行为为从params参数取一个字符串
也可以用于类型转换的场景中使用
再比如，再lang-set场景中，value默认是visit修饰符，
可以使用value.string直接输入字符串，
或者使用eval/eval-java等修饰符改变行为为获取eval的结果

eval是使用ognl进行实现
ognl将会以上下文的Map对象为根对象
同时会添加名为$root的变量，也是这个上下文Map
参见：DefaultJdbcProcedureExecutor.innerEval

eval-java是使用jdk的内存编译技术实现的
原理是封装为一个临时的类，执行固定方法实现
函数原型如下：
public Object exec(JdbcProcedureExecutor executor,Map<String,Object> params) throws Throwable {
}
或者参见：JdbcProcedureJavaCaller接口定义
因此，你要做的就是补全函数体内部的内容
如果是多行或者单行时，会自动检测最后的return关键字和分号进行补全
例如：new Date()
即可，不用 return new Date();
但是如果比较复杂，那最好还是自己完善语法

eval-js使用java中的js引擎进行处理
以局部作用域的方式运行，局部变量中和java一样，传递了三个参数context,executor,params
你可以添加自己的逻辑
js引擎执行完毕之后，会返回之后一次执行的结果

eval-groovy使用groovy引擎进行处理
原理是封装为一个函数进行执行
函数原型如下：
def exec(JdbcProcedureExecutor executor, Map<String,Object> params) throws Throwable {
    // 这里就是下面的脚本内容
}
或者参见：JdbcProcedureJavaCaller接口定义
因此，你要做的就是补全函数体内部的内容

eval-ts使用TinyScript引擎进行处理
只注入params进行执行，但是由于params.executor也注入了executor变量
因此也可以直接使用executor进行访问到
 -->
<procedure id="">
    <!--
    调试器，在此处中断执行，等待继续执行
    可用于在此时查看上下文变量
    test用于作为条件断点使用
    tag可用于标识是哪个断点
    推荐对 BasicJdbcProcedureExecutor.openDebugger 方法添加断点
    以结合此处的作用，使用到IDEA的断点功能
    或者在 DebuggerNode 节点上添加断点也可实现
    -->
    <debugger tag="" test=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <debugger tag="execSql"/>
        <debugger tag="getUserInfo" test="user==null"/>
    </script-segment>

    <!--
    使用系统输出行，以tag开头，其余变量附加在其他属性上即可
    tag默认以字符串方式解析，等价于 tag.string
     -->
    <lang-println tag="" aaa=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-printf tag="userInfo" userName="user.name" age="user.age" now.date-now=""/>
    </script-segment>

    <!--
    使用value指定的模版进行渲染输出,同样支持tag属性标签
    tag默认以字符串方式解析，等价于 tag.string
     -->
    <lang-printf tag="" value.body-xml.trim=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-printf tag="userInfo" value="username:${user.name}"/>
        <lang-printf tag="userInfo" value.body-text.trim="">
            username: ${user.name}
        </lang-printf>
    </script-segment>

    <!-- 语句段，可使用script-include进行引用，id唯一即可，root表示语句段使用了哪些变量，可以作为变量声明 -->
    <script-segment id="" root="">
        <![CDATA[
            112
        ]]>
    </script-segment>
    <!-- 引用语句段，可使用script-segment定义的语句段，refid表示引用的语句段，其他属性表示传递给语句段的根变量 -->
    <script-include refid="" root="" aaa=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <script-include refid="demo"/>
        <script-include refid="demo" IN_LOCATION="V_PROCEDURE_NAME"/>
    </script-segment>

    <!--
    从value指定的值赋值到result指定的值中，
    如果为数值型，可以使用radix指定进制
    如果为日期型，可以使用pattern指定格式化的串
    这里value为输入，又添加了:int修饰符，则表示这个值是一个int型立即数，不需要从context里面取
    value默认以visit访问，等价于 value.visit
    radix默认以int访问，等价于 radix.int
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-set value.int="" radix="" pattern="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-set result="v_val" value.int="1"/>
        <lang-set result="v_val" value.boolean="true"/>
        <lang-set result.trim="v_val" value.render="welcome ${userName}! "/>
        <lang-set result="v_i" value.eval="v_i+1"/>
        <lang-set result="v_now" value.date-now=""/>
        <lang-set result="v_null" value.null=""/>
        <lang-set result="user.nickName" value="user.userName"/>
        <lang-set result="v_now" value.eval-java="new Date()"/>
        <lang-set result="v_now" value.eval-ts="new Date()"/>
        <lang-set result="v_year" value.date="2025-01-02" pattern="yyyy-MM-dd"/>
        <lang-set result="v_hex" value.string="6fd" radix="16"/>
        <lang-set result.body-text.trim="">
            text
        </lang-set>
        <lang-set result.body-text.trim.render="">
            hello ${user.nickName}!
        </lang-set>
    </script-segment>


    <!--
    格式化日期
    value默认以visit访问，等价于 value.visit
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-format-date value="" pattern="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-format-date result="v_str" value.eval-ts="new Date()" pattern="yyyy-MM-dd"/>
        <lang-format-date result="v_str" value="v_begin_time" pattern="yyyyMMdd"/>
    </script-segment>

    <!--
    格式化字符串
    value默认以visit访问，等价于 value.visit
    pattern默认以string访问，等价于 pattern.string
     -->
    <lang-format value="" pattern="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-format result="v_str" value="12.125" pattern="%.2f"/>
        <lang-format result="v_str" value="v_money" pattern="your account has %.2f$"/>
        <lang-format result="v_str" value.date-now="" pattern="yyyy-MM-dd"/>
    </script-segment>

    <!--
    字符串拼接
    separator默认以string访问，等价于 separator.string
    其他argx以visit访问，等价于 argx.visit
     -->
    <lang-string-join separator="" result="" arg0="" arg1=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-string-join result="v_vals" separator="," arg0.string="a.username" arg1.int="2" arg2="v_now"/>
        <lang-string-join result="v_str" arg0.string="[" arg1.int="0" arg2.string="]"/>
    </script-segment>

    <!--
    创建一个新的参数，用于为内部调用其他过程提供干净的上下文参数，避免参数污染
    同时，由于被调用方的上下文参数在调用方持有，调用方也可以获取到被调用方执行完的结果
    传入参数默认以visit访问，等价于 aaa.visit
    -->
    <lang-new-params result="" aaa="" bbb=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-new-params result="callParams" IN_SUM_MONTH="V_SUM_MONTH" IN_CITY_CODE.int="10010"/>
        <lang-new-params result="callParams"/>
    </script-segment>

    <!--
    调用其他存储过程，id表示目标的id,
    可以指定一个params参数作为根上下文参数，这样可以避免上下文污染，如果不指定，则直接使用新的上下文，新的上下文可用过result进行获取到
    直接使用目标变量age名来传递值
    params默认以visit访问，等价于 params.visit
    result为保存调用的参数，可用于从中获取调用的结果，如果同时指定的params，则result可以不用指定，因为result里面的值，实际上就是params里面的值
    params_share默认以boolean访问，等价于params_share.boolean
    其他传入参数默认以visit访问，等价于 age.visit
    refid的值，不仅仅只有procedure标签上的ID才算，其他的XML标签上的ID也算
    同时，在bean中，如果是JdbcProcedureJavaCaller的实现类，同时类上具有@JdbcProcedure注解指定过程名称
    如果被加入到beans中的话，注解指定的名称也可以使用，这样就实现了JAVA类实现与XML脚本实现的统一调用
    如果params_share指定为true，则直接使用本过程使用的上下文作为调用上下文，不会产生新的上下文，主要用于一些特殊场景中使用
     -->
    <procedure-call refid="" params="" age="" result="" params_share=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <!-- 调用函数 -->
        <procedure-call refid="F_TEST" result="callParams" IN_SUM_MONTH="V_SUM_MONTH"/>
        <!-- 因为是函数，所以返回值就叫return，直接取值即可 -->
        <lang-set result="V_IS_TEST" value="callParams.return"/>

        <!-- 调用过程 -->
        <procedure-call refid="SP_TEST" result="callParams" IN_SUM_MONTH.int="202501"/>
        <!-- 因为调用的是存储过程，存在多个输出参数，因此需要根据定义的输出参数获取值，比如这里定义的输出参数O_FLAG和O_MSG -->
        <lang-set result="V_FLAG" value="callParams.O_FLAG"/>
        <lang-set result="V_MSG" value="callParams.O_MSG"/>

        <!-- 使用预定义参数 -->
        <lang-new-params result="callParams" IN_SUM_MONTH="V_SUM_MONTH"/>
        <procedure-call refid="SP_MAIN" params="callParams"/>

        <!-- 共享过程上下文参数 -->
        <procedure-call refid="SP_MAIN" params_share="true"/>

        <!-- 动态执行过程名称 -->
        <lang-set result="V_SP_NAME" value.string="SP_MAIN"/>
        <procedure-call refid.visit="V_SP_NAME" params_share="true"/>
    </script-segment>


    <!--
    参数使用和procedure-call一致
    区别为，当procedure-call调用要取返回值时，result得到的是调用的全部params参数的Map
    而function-call针对function函数类型进行了调整，result的值取到的就是函数调用的返回值，而不是params这个Map
    此类调用，需要结合<lang-return value=""/>进行使用
    即返回时携带返回值返回
    内部实际上是通过子过程的params对象Map绑定的
    这个result就是绑定到ParamsConsts.RETURN绑定的键上
    -->
    <function-call refid="" params="" age="" result="" params_share=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <!-- result 就是函数的返回值,其他参数的用法和procedure-call一致 -->
        <function-call refid="F_TEST" result="V_IS_TEST" IN_SUM_MONTH.int="202501"/>
    </script-segment>

    <!--
    调用java指定的回调方法
    target需要为JdbcProcedureJavaCaller的实现类
    优先从上下文Map的beans中进行获取
    如果获取不到再从params中获取
    如果依旧获取不到，则把target的值当做class的类名进行反射调用
    因此，查找优先级为：bean名称>params访问变量>bean全类名>bean短类名>反射类名
    获取得到，并且是实现类则进行调用，注意，此过程不会创建新的params上下文，直接使用所在的params上下文
    因此不需要进行参数传递，这点区别于procedure-call
    否则不进行调用
    -->
    <java-call target="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <java-call target="funcTestCaller" result="V_IS_TEST"/>
        <java-call target="com.test.caller.FuncTestCaller" result="V_IS_TEST"/>
    </script-segment>

    <!--
    返回，结束此过程
    如果过程只返回一个值，为函数型调用时，可以使用value属性指定返回值
    指定的返回值可使用function-call调用的result获取到，
    这个value值将会绑定到ParamsConsts.RETURN绑定的键上
    也可以使用procedure-call的result获取返回值
    但是，区别是result得到的是params的Map
    还需要从这个Map中取名为ParamsConsts.RETURN的键的值，才是这里返回的value值
    -->
    <lang-return value=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-return/>
        <lang-return value.int="0"/>
        <lang-return value="V_IS_OK"/>
    </script-segment>

    <!--
    抛出异常，value指定为message内容，type指定为异常类型，cause可选为造成异常的异常对象
    value默认以string访问，等价于 value.string
    type以string访问，不支持修饰符
    cause以visit访问，不支持修饰符
     -->
    <lang-throw value="" type="" cause=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-throw type="RuntimeException" value="bad parameter"/>

        <lang-try>
            <lang-body>

            </lang-body>
            <lang-catch e="e">
                <lang-throw type="RuntimeException" value="bad parameter" cause="e"/>
            </lang-catch>
        </lang-try>
    </script-segment>

    <!--
    用于指定一小段脚本，来设置一个变量值到result指定的变量名中
    value默认以string访问，等价于 value.string
     -->
    <lang-eval value="" result="">
        11
    </lang-eval>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-eval result="v_ok" value="v_cnt > 0"/>

        <lang-eval result="v_len" value="v_str.length()"/>

        <lang-eval result="v_i">
            v_i+1
        </lang-eval>
    </script-segment>

    <!--
    用于指定一段字符串到result指定的变量名中
    对于lang-string/lang-render可以添加_lang属性，
    用于配合插件对内部的文本进行对应的高亮，例如：_lang="sql"
    支持的语言包括，java,sql
    还有你的IDEA支持的一些其他语言，可能的值有 scala,shell,groovy,sql,java,mysql,oracle,vue等等
    具体依赖于你的IDEA安装过哪些语言的插件，
    你也可以通过尝试的方式，看看内部的内容是否发生了高亮/颜色变化来判断是否支持该语言
     -->
    <lang-string result="" _lang="java">

    </lang-string>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-string result.trim="v_str">
            123
                456
        </lang-string>
        <lang-string result.trim.align="v_str">
            | 123
            |456
        </lang-string>
    </script-segment>


    <!-- 用于使用模版引擎进行渲染一段字符串到result指定的变量名中 -->
    <lang-render result="" _lang="sql">

    </lang-render>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-render result="v_sql" _lang="sql">
            select * from ${tableName}
                     where ${colName} = ${colEqValue}
        </lang-render>

    </script-segment>

    <!--
    lang-开头的表示语言的基本语句，这个就是对应if语句，test表示判定条件语句
    test默认以test访问，等价于 test.test
     -->
    <lang-if test="">

    </lang-if>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-if test="v_cnt==0">
            <lang-set result="O_FLAG" value.int="-1"/>
            <lang-return/>
        </lang-if>

        <lang-if test="v_grade in {'A','B','C'}">
            <sql-update>
                update sys_user set score =score+10 where grade=#{v_grade}
            </sql-update>
        </lang-if>

        <lang-if test.visit="v_fail">
            <lang-return/>
        </lang-if>

        <lang-if test='v_str.startsWith("DIM")'>
            <lang-return value.int="-1"/>
        </lang-if>

        <lang-if test='v_str.contains("VAR")'>
            <lang-return value.int="-1"/>
        </lang-if>
    </script-segment>

    <!-- 对应的就是if-else-if这种语句或者Switch这种分支语句 -->
    <lang-choose>
        <!--
        表示一个分支
        test默认以test访问，等价于 test.test
         -->
        <lang-when test="">

        </lang-when>
        <!-- 其他分支，当所有when分支都不满足时，执行此分支，对应else分支 -->
        <lang-otherwise>

        </lang-otherwise>
    </lang-choose>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-choose>
            <lang-when test="v_grade in {1,2,3}">
                <lang-set result="v_grade_color" value.string="blue"/>
            </lang-when>
            <lang-when test="v_grade==0">
                <lang-set result="v_grade_color" value.string="skyblue"/>
            </lang-when>
            <lang-otherwise>
                <lang-set result="v_grade_color" value.string="red"/>
            </lang-otherwise>
        </lang-choose>
    </script-segment>

    <!--
    对应一个foreach循环，对一个集合进行迭代，collection表示被迭代的集合，item表示迭代变量的名称
    item默认值为item，可缺省
    first默认值为first，可缺省
    index默认值为index，可缺省
    collection以visit访问，不支持修饰符
    item以string访问，不支持修饰符
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-foreach collection="" item="" first="" index="">

    </lang-foreach>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-foreach collection="v_user_list" item="item" first="isFirst" index="i">
            <lang-if test="!isFirst">
                <lang-set result="v_str" value.render="${v_str},"/>
            </lang-if>
            <lang-set result="v_str" value.render="${v_str}${i}:${item.userName}"/>
        </lang-foreach>
    </script-segment>

    <!--
    对应一个计数型循环，表示从begin数开始每次增加incr的步长直到end结束，item表示迭代变量的名称
    begin默认值为0，可缺省
    incr默认值为1，可缺省
    item默认值为item，可缺省
    first默认值为first，可缺省
    index默认值为index，可缺省
    begin默认以int访问，等价于 begin.int
    end默认以int访问，等价于 end.int
    incr默认以int访问，等价于 incr.int
    item以string访问，不支持修饰符
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-fori begin="" end="" incr="" item="" first="" index="">

    </lang-fori>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-fori begin.int="2" end.int="100" incr.int="3">
            <lang-set result="v_count" value.eval="v_count+1"/>
        </lang-fori>

        <lang-fori begin="v_index" end.int="100" >
            <lang-set result="v_count" value.eval="v_count+1"/>
            <lang-if test="v_index>= v_str.length()">
                <lang-break/>
            </lang-if>
        </lang-fori>

        <lang-fori end.int="100" >
            <lang-set result="v_count" value.eval="v_count+1"/>
        </lang-fori>
    </script-segment>

    <!--
    对应一个while语句，test表示循环条件的判断语句
    first默认值为first，可缺省
    index默认值为index，可缺省
    test默认以test访问，等价于 test.test
    first以string访问，不支持修饰符
    index以string访问，不支持修饰符
     -->
    <lang-while test="" first="" index="">
        <!-- 对应continue-->
        <lang-continue/>
        <!-- 对应break -->
        <lang-break/>
    </lang-while>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-while test="v_i>0">
            <lang-if test="v_i==10">
                <lang-continue/>
            </lang-if>
            <lang-if test="v_i &lt; v_cnt">
                <lang-break/>
            </lang-if>
            <lang-set result="v_i" value.eval="v_i-1"/>
        </lang-while>
    </script-segment>

    <!--
    调用函数，在target指定的对象上调用method方法，并传入argx参数
    当指定target时，method不用指定类名
    当method是静态函数式，target没有影响
    method是全限定的方法名（即类名.方法名，例如Math.random,Date.new）,
    new方法名，指调用构造函数
    target表示在哪个对象上调用（有target时，不需要指定全限定方法名，只需要方法名即可）,
    argx表示传入的参数，后面的数字表示参数的次序，
    result用于记录调用的结果保存到哪个变量中
    method以string访问，不支持修饰符
    target默认以visit访问，等价于 target.visit
     -->
    <lang-invoke method="" target="" arg0="" arg1="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-invoke result="v_str" target="v_str" method="replaceAll" arg0.string="\s+" arg1.string=""/>

        <lang-invoke result="v_num" method="parseInteger" arg0.string="11"/>

    </script-segment>

    <!-- 对应一个异常处理块try-catch-finally -->
    <lang-try>
        <!-- 表示异常处理的内容，对应try的内容块 -->
        <lang-body>

        </lang-body>
        <!--
        表示一个异常catch块，type指定要捕获的异常类型，var表示异常的变量名
        type以string访问，不支持修饰符
        e以string访问，不支持修饰符
         -->
        <lang-catch type="" e="">

        </lang-catch>
        <!-- 对应finally语句块 -->
        <lang-finally>

        </lang-finally>
    </lang-try>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-try>
            <lang-body>
                <sql-update script="v_sql"/>
            </lang-body>
            <lang-catch type="ArithmeticException|java.sql.SQLException" e="e">
                <lang-println tag="execError" SQL="v_sql" EXCEPTION="e"/>
            </lang-catch>
            <lang-catch type="RuntimeException" e="e">
                <lang-println tag="runError" SQL="v_sql" EXCEPTION="e"/>
            </lang-catch>
        </lang-try>

        <lang-try>
            <lang-body>
                <sql-update script="v_sql"/>
            </lang-body>
            <lang-catch e="e">
                <lang-println tag="execError" SQL="v_sql" EXCEPTION="e"/>
            </lang-catch>
        </lang-try>

        <lang-try>
            <lang-body>
                <sql-update script="v_sql"/>
            </lang-body>
            <lang-finally>
                <sql-update script="v_log_sql"/>
            </lang-finally>
        </lang-try>

        <lang-try>
            <lang-body>
                <sql-update script="v_sql"/>
            </lang-body>
        </lang-try>
    </script-segment>

    <!--
    对应synchronized关键字,允许指定target，不指定则对当前节点的上下文context同步
    target默认以visit访问，等价于 target.visit
     -->
    <lang-synchronized target="">

    </lang-synchronized>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-synchronized target="global">
            <sql-update script="v_sql"/>
        </lang-synchronized>
    </script-segment>

    <!--
    用法类似lang-render
    区别是lang-render的结果是string类型，需要自信处理以避免sql注入
    而sql-script的结果是BindSql类型，使用占位符表示值，内部就是mybatis支持的标签，对标mybatis的sql标签
    这个result结果，可用于在其他sql-script/sql-query-*/sql-update等sql语句中作为#{}/${}占位符使用
    -->
    <sql-script result="">

    </sql-script>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-script result="v_sql">
            select *
            from ${tableName}
            <where>
                <if test="status!=null">
                    and status=#{status}
                </if>
            </where>
        </sql-script>
    </script-segment>

    <!--
    表示一个查询语句，预期为一行数据，执行结果放到result指定的变量名中；
    对于sql-开头的标签，都允许带有datasource属性来制定使用哪个数据源，也都允许带有script属性指定要执行的SQL来源于哪个变量，
    对于sql-query-开头的标签，都允许带有result-type属性来指定结果集转换为什么类型
    datasource默认以string访问，等价于 datasource.string
    script默认以visit访问，等价于 script.visit
    result-type默认以class访问，等价于 result-type.class
    query-row支持limited属性，要求值为boolean类型
    则使用分页包装的方式只取第一条数据，语句将会被包装为分页数据
     -->
    <sql-query-row datasource="" script="" result="" result-type="">

    </sql-query-row>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-query-row result="tmpRowMap" result-type="Map">
            select * from sys_user
            where id=#{id}
        </sql-query-row>

        <sql-query-row datasource="slave" result="tmpRowMap">
            select * from sys_user
            where id=#{id}
        </sql-query-row>

        <sql-query-row result="anyRow" limited="true">
            select * from sys_user
            where status=#{status}
        </sql-query-row>

        <sql-query-row result="v_user" script="v_sql"/>

        <sql-query-row result="tmpUser" limited="true">
            <sql-dialect databases="oracle,dm,ob">
                SELECT * FROM SYS_USER WHERE STATUS=#{status}
            </sql-dialect>
            <sql-dialect databases="mysql,gbase,mariadb">
                select * from sys_user where status=#{status}
            </sql-dialect>
        </sql-query-row>
    </script-segment>

    <!--
    表示一个查询语句，预期为多行数据，执行结果放到result指定的变量名中
    query-list支持offset和limit属性用来支持分页数据获取，数据类型需要为Integer
    offset起始值为0，为数据序号
    limit是取的数据个数
    对应例如mysql数据库中的limit ${offset},${limit}语句
    其他数据库也一样，只不过根据不同的数据库类型实现相同的分页包装
    内部语句会被包装为分页语句进行执行
     -->
    <sql-query-list result="">
        <trim prefix="select" prefixOverrides="," suffixOverrides=",">
            id,
            username,
            <if test="false">
                password,
            </if>
            nickname,
        </trim>
        from sys_user
        <where>
            <if test="true">
                <choose>
                    <when test="true">

                    </when>
                    <when test="true">

                    </when>
                    <otherwise>

                    </otherwise>
                </choose>
            </if>
            <foreach collection="list" item="item" open="(" separator="," close=")">

            </foreach>
            <include refid="permsCondition"/>
        </where>
    </sql-query-list>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-query-list result="userList">
            select * from sys_user where del_flag=1
        </sql-query-list>

        <sql-query-list result="userList" script="v_sql"/>

        <sql-query-list script="v_sql" offset="100" limit="15"/>
    </script-segment>

    <!--
    表示一个查询语句，预期为单个值，仅一行一列的值，执行结果放到result指定的变量中
    query-object支持limited属性，要求值为boolean类型
    则使用分页包装的方式只取第一条数据，语句将会被包装为分页数据
     -->
    <sql-query-object result="">

    </sql-query-object>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-query-object result="v_cnt" result-type="long">
            select count(1) from sys_user where del_flag=1
        </sql-query-object>

        <sql-query-object result="v_code" result-type="string">
            select dict_code form sys_dict where dict_type=#{dictType} and dict_value=#{dictValue}
        </sql-query-object>

        <sql-query-object result="v_cnt" script="v_sql" result-type="long"/>
    </script-segment>

    <!-- 表示一个更新语句，预期为JDBC执行update的返回值，执行结果放到result指定的变量中 -->
    <sql-update result="">
        <!--
         用于在sql-系列的标签中，用于解决数据库的方言问题
         通过databases指定支持的数据库类型列表，多个用逗号分隔，不区分大小写
         允许使用script属性指定脚本
         这个标签是可选的
          script默认以visit访问，等价于 script.visit
          databases以string访问，不支持修饰符
         -->
        <sql-dialect script="" databases="mysql,gbase,mariadb">
            update sys_user
            <set>
                <if test="true">
                    username=#{username}
                </if>
            </set>
            <where>
                id=#{id}
            </where>
        </sql-dialect>
        <sql-dialect databases="oracle,dm">
            delete from sys_user
            where
            <if test="true">
                id=#{id}
            </if>
        </sql-dialect>
        <sql-dialect databases="postgre">
            insert into sys_user
            <trim prefix="(" suffix=")" prefixOverrides="," suffixOverrides=",">
                <if test="true">
                    username,
                </if>
            </trim>
            values
            <trim prefix="(" suffix=")" prefixOverrides="," suffixOverrides=",">
                <if test="true">
                    #{username},
                </if>
            </trim>
        </sql-dialect>
        <sql-dialect databases="sqlserver">

        </sql-dialect>
    </sql-update>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-update>
            delete from sys_user where del_flag=#{delFlag}
        </sql-update>

        <sql-update result="effectRows">
            update sys_user set status=1 where create_time > #{activeDate}
        </sql-update>

        <sql-update script="v_sql"/>
    </script-segment>

    <!--
    表示JDBC的事务控制，begin表示开始事务。commit表示提交事务，rollback表示回滚事务,none表示不开启事务
    isolation以string访问，支持Connection.TRANSACTION_xxx的数字值，或者xxx的字符值，不区分大小写
     -->
    <sql-trans-begin isolation="Conne"/>
    <sql-trans-commit/>
    <sql-trans-rollback/>
    <sql-trans-none/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-try>
            <lang-body>
                <sql-trans-begin/>
                <sql-update script="v_sql"/>
                <sql-trans-commit/>
            </lang-body>
            <lang-catch>
                <sql-trans-rollback/>
            </lang-catch>
        </lang-try>
        <sql-trans-none/>
    </script-segment>

    <!--
    异步执行，await表示是否需要等待执行结束，delay表示延迟多长时间再开始执行
    await默认以boolean访问，等价于 await.boolean
    delay默认以long访问，等价于 delay.long
    time-unit以string访问，不支持修饰符，为TimeUnit的枚举字符串值，不区分大小写
     -->
    <lang-async await.boolean="" delay="" time-unit="">

    </lang-async>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-async>
            <sql-update script="v_sql"/>
        </lang-async>

        <lang-async await="true">
            <sql-query-object result="v_cnt" script="v_sql" result-type="long"/>
        </lang-async>
        <lang-if test="v_cnt==0">
            <lang-return/>
        </lang-if>
    </script-segment>

    <!--
    java 中的count-down-latch
    count默认以eval访问，等价于 count.eval ，因为使用latch的场景大多数和集合等有关，所以选用默认eval类方便获取集合的大小
     -->
    <lang-latch count="" result=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-latch result="v_latch" count.int="3"/>

        <lang-latch result="v_latch" count="userList.size()"/>
    </script-segment>

    <!--
    多个任务并行
    await默认以boolean访问，等价于 await.boolean
     -->
    <lang-async-all await="">
        <!-- 每个任务仅有delay延时可用 -->
        <lang-async delay="" time-unit="">
            <!--
            对name对应的latch对象进行count-down操作
            name默认以visit访问，等价于 name.visit 目的是取到对应的latch对象
             -->
            <lang-latch-down name=""/>
        </lang-async>
    </lang-async-all>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-async-all await="true">
            <lang-async>
                <sql-query-object result="v_cnt" script="v_user_count_sql" result-type="long"/>
            </lang-async>
            <lang-async>
                <sql-query-object result="roleKey" script="v_default_role_sql" result-type="string"/>
            </lang-async>
        </lang-async-all>
        <lang-if test="v_cnt==0">
            <lang-return/>
        </lang-if>
        <sql-update>
            update sys_user
            set role_key=#{roleKey}
            where role_key is null
        </sql-update>
    </script-segment>

    <!--
    等待名为name的latch对象
    name默认以visit访问，等价于 name.visit 目的是取到对应的latch对象
    timeout默认以long访问，等价于 timeout.long
    time-unit以string访问，不支持修饰符，为TimeUnit的枚举字符串值，不区分大小写
     -->
    <lang-latch-await name="" timeout="" time-unit=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-latch-await name="v_latch"/>
        <lang-latch-await name="v_latch" time-unit="SECONDS" timeout="30"/>

        <lang-latch result="v_latch" count="userList.size()"/>
        <lang-foreach collection="userList" item="item">
            <lang-async>

                <lang-try>
                    <lang-body>

                        <sql-update>
                            update sys_user
                            set user_name=trim(user_name)
                            where user_name=#{item.userName}
                        </sql-update>

                    </lang-body>
                    <lang-catch type="Throwable">

                    </lang-catch>
                    <lang-finally>

                        <lang-latch-down name="v_latch"/>

                    </lang-finally>
                </lang-try>

            </lang-async>
        </lang-foreach>
        <lang-latch-await name="v_latch"/>

    </script-segment>


    <!--
    通过遍历结果集的方式，提供类似游标的操作能力，通过sql-query-list进行查询遍历，
    每次查询分页大小为batch-size，将item的值提供给lang-body进行执行
    如果accept-batch值为true，则传递给lang-body的item参数为一个batch-size大小的list
    否则，只是一行数据传给item
    batch-szie默认值为2000，可缺省
    item默认值为item，可缺省
    accept-batch默认值为false，可缺省
    batch-size默认以int访问，等价于 batch-size.int
    item以string访问，不支持修饰符
    accept-batch默认以boolean访问，等价于 accept-batch.boolean
     -->
    <sql-cursor batch-size="300" item="" accept-batch="false">
        <sql-query-list datasource="" script="" result-type="">

        </sql-query-list>
        <lang-body>
        </lang-body>
    </sql-cursor>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-cursor item="cur_item">
            <sql-query-list>
                select * from sys_user
            </sql-query-list>
            <lang-body>
                <sql-update>
                    update sys_user
                    set user_name=trim(user_name)
                    where id=#{cur_item.id}
                </sql-update>
            </lang-body>
        </sql-cursor>

        <sql-cursor item="v_cur">
            <sql-query-list script="v_sql"/>
            <lang-body>
                <sql-update>
                    update sys_user
                    set user_name=trim(user_name)
                    where id=#{v_cur.id}
                </sql-update>
            </lang-body>
        </sql-cursor>
    </script-segment>

    <!--
    动态编译为java类进行执行
    允许没有import/member部分
    允许没有body部分
    则eval-java内部直接为Java代码
    实际上，eval-java的body内容
    会放到JdbcProcedureJavaCaller的实现类函数中执行
    也就是在这样的函数环境中执行
    public Object exec(JdbcProcedureExecutor executor, Map<String, Object> params) throws Throwable {
        // 这里就是下面的脚本
    }
    因此，常规来说，需要满足Java函数段的语法规则
    也就是具有return语句，以及分号
    但是，为了适应脚本语言特点
    允许忽略最后一行的return以及分号
     -->
    <lang-eval-java result="">
        <!-- import 语句部分 -->
        <lang-java-import>

        </lang-java-import>
        <!-- member语句部分，也就是成员变量和成员函数 -->
        <lang-java-member>

        </lang-java-member>
        <!-- body部分，需要带有return语句 -->
        <lang-java-body>

        </lang-java-body>
    </lang-eval-java>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-eval-java result="v_now">
            return new Date();
        </lang-eval-java>

        <lang-eval-java>
            executor.visitSet(params,"v_now",new Date());
            return null;
        </lang-eval-java>

        <lang-eval-java>
            <lang-java-member>
                public Object nvl(Object a,Object b){
                    return a==null?b:a;
                }
            </lang-java-member>
            <lang-java-body>
                return nvl(executor.visit("v_sql",params),"");
            </lang-java-body>
        </lang-eval-java>
    </script-segment>

    <!--
    动态执行javascript脚本
    环境中具有以下变量，所有的变量都存储在params中
    因此，取值和保存值都通过操作params实现
    JdbcProcedureExecutor executor
    Map<String,Object> params
     -->
    <lang-eval-javascript result="">

    </lang-eval-javascript>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-eval-javascript result="v_size">
            params.get("v_i")+params.get("v_cnt")
        </lang-eval-javascript>

        <lang-eval-js result="v_now">
            new Date()
        </lang-eval-js>
    </script-segment>

    <!-- 动态执行javascript脚本,实际上是一个别名 -->
    <lang-eval-js result="">

    </lang-eval-js>


    <!-- 动态执行tiny-script脚本 -->
    <lang-eval-tinyscript result="">

    </lang-eval-tinyscript>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-eval-tinyscript>
            v_i=${v_i}+1;
        </lang-eval-tinyscript>

        <lang-eval-ts result="v_i">
            ${v_i}+1
        </lang-eval-ts>
    </script-segment>

    <!-- 动态执行tiny-script脚本,实际上是一个别名 -->
    <lang-eval-ts result="">

    </lang-eval-ts>

    <!--
    动态执行groovy脚本
    环境中具有以下变量，所有的变量都存储在params中
    因此，取值和保存值都通过操作params实现
    实际上是将脚本置于函数中执行
    def exec(JdbcProcedureExecutor executor, Map<String,Object> params) throws Throwable {
        // 这里就是下面的脚本内容
    }
     exec(executor,params);
     -->
    <lang-eval-groovy result="">

    </lang-eval-groovy>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-eval-groovy result="v_now">
            new Date()
        </lang-eval-groovy>

        <lang-eval-groovy result="v_cnt">
            params.v_cnt+1
        </lang-eval-groovy>
    </script-segment>

    <!--
     创建一个数据库连接范围，对datasources中指定的这些数据源
     创建新的连接进行使用，使用完毕之后自动关闭新创建的这些连接
     同时，执行完毕之后，恢复域外的连接到上下文中
     多个数据源用逗号分隔，特别的，all表示全部数据源
     datasources使用string访问，不支持修饰符
     -->
    <sql-scope datasources="">

    </sql-scope>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-scope datasources="primary">
            <sql-update>
                insert into sys_log(location,create_time,content)
                values (#{location},sysdate,#{content})
            </sql-update>
        </sql-scope>
    </script-segment>

    <!-- 对当前线程进行休眠 -->
    <lang-sleep timeout="" time-unit=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <lang-sleep timeout="30" time-unit="MILLISECONDS"/>
    </script-segment>

    <!--
    进行数据库表ETL对拷，注意，此过程全程使用的是新链接
    每次从sql-query-list中读取read-batch-size个元素
    也允许不使用sql-query-list,直接使用etl-extra指定源表即可
    写入到load指定的数据源datasource的table表中
    允许在开头是进行before-truncate清空表操作
    在进行commit-size条数据的写入之后，提交一次事务
     -->
    <sql-etl read-batch-size=""
             write-batch-size=""
             before-truncate=""
             commit-size="">
        <sql-query-list>

        </sql-query-list>
        <etl-extra datasource="" table=""/>

        <!--
        进行列的转换，只有在target写明的列才会进行传输
        source表示原始的列名
        target表示目标列名，将用于load中构造插入语句的目标列名
        type用于指定目标接受的类型，值应该是一个class类型
        source默认使用string访问，等价于 source.string ,可使用其他修饰符实现原始数据的转换或覆盖
        target使用string访问，等价于 target.string, 不支持修饰符
        -->
        <etl-transform source="" target="" type=""/>
        <!--
        进行数据的写入，将数据写入到datasource指定的数据源中
        目标表用table表示
        -->
        <etl-load datasource="" table=""/>

        <!--
        两个声明周期钩子，分别对应ETL前和执行后的操作
        例如执行前清空表，或者删除目标表的部分数据
        或者ETL到的是临时表，ETL结束后再批量插入到目标表等场景
         -->
        <etl-before>

        </etl-before>
        <etl-after>

        </etl-after>
    </sql-etl>
    <!-- 举例 -->
    <script-segment id="demo">
        <sql-etl>
            <etl-extra datasource="oracle" table="COMM.SYS_DICT"/>
            <etl-load datasource="primary" table="DIM_SYS_DICT"/>
        </sql-etl>

        <sql-etl>
            <sql-query-list datasource="oracle">
                select * from COMM.SYS_DICT where status=1
            </sql-query-list>
            <etl-load datasource="primary" table="DIM_SYS_DICT"/>
            <etl-before>
                <sql-update datasource="primary">
                    truncate table DIM_SYS_DICT
                </sql-update>
            </etl-before>
        </sql-etl>
    </script-segment>

    <!--
    添加指定的包名前缀，或使用类名所在的包名前缀，
    用于简化lang-invoke是的method，
    或者其他的需要进行查找class的过程中，在JdbcProcedureExecutor.loadClass中进行查找类使用
    不用写全限定类名，只需要用短类名，
    例如：原本要写method=org.apache.StringUtils.trim方法
    如果，已经注册了
    <context-load-package package="org.apache."/>
    或者
    <context-load-package class="org.apache.StringUtils"/>
    都添加了包名前缀：org.apache.
    这样，只需要写method=StringUtils.trim
    这样，也就能够直接等价于method=org.apache.StringUtils.trim
    实际，作用于ContextHolder.LOAD_PACKAGE_SET中
     -->
    <context-load-package package="" class=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <context-load-package package="com.test.utils"/>
        <context-load-package class="com.test.utils.StringUtils"/>
    </script-segment>

    <!--
    添加class中的所有public方法，
    这个方法名将会直接适用于lang-invoke是的method，
    例如有这样的一个方法 public static String org.apache.StringUtils.regexReplace(...)
    则，method=regexReplace就会被注册，
    当lang-invoke的method=regexReplace被调用时，就会优先调用这个被注册的方法
    实际，作用于ContextHolder.INVOKE_METHOD_MAP中
    -->
    <context-invoke-method-class class=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <context-invoke-method-class class="com.test.util.StringUtils"/>
    </script-segment>

    <!--
    添加class中的所有public static方法，
    这个方法名将会直接适用于修饰符上，则修饰符就添加了这个类中的静态方法
    要求，静态方法，一个入参，带有返回值
    定义大致为：public static Object name(Object v);
    例如有这样的一个方法 public static org.apache.StringUtils.trimAll(String str)
    则，method=trimAll就会被注册，
    当lang-invoke的method=trimAll被调用时，就会优先调用这个被注册的方法
    实际，作用于ContextHolder.CONVERT_METHOD_MAP中
    -->
    <context-convert-method-class class=""/>
    <!-- 举例 -->
    <script-segment id="demo">
        <context-convert-method-class class="com.test.util.ConvertUtils"/>
    </script-segment>

</procedure>